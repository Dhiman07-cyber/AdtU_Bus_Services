import { NextResponse } from 'next/server';
import { auth, db as adminDb } from '@/lib/firebase-admin';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { idToken, busId, lat, lng, accuracy, message, timestamp, routeId, stopName, stopId, stopLat, stopLng } = body;

    // Get token from either body or Authorization header
    let token = idToken;
    if (!token) {
      const authHeader = request.headers.get('authorization');
      if (authHeader && authHeader.startsWith('Bearer ')) {
        token = authHeader.substring(7);
      }
    }

    if (!token || !busId) {
      return NextResponse.json(
        { error: 'Missing required fields: idToken, busId' },
        { status: 400 }
      );
    }

    if (!auth) {
      return NextResponse.json(
        { error: 'Firebase Admin not initialized' },
        { status: 500 }
      );
    }

    // Verify Firebase ID token
    const decodedToken = await auth.verifyIdToken(token);
    const studentUid = decodedToken.uid;

    // Get student data - try direct doc lookup first, then query by uid field
    let studentDoc = await adminDb.collection('students').doc(studentUid).get();
    let studentData: any = null;

    if (studentDoc.exists) {
      studentData = studentDoc.data();
    } else {
      // Student document ID might be different from auth UID - query by uid field
      console.log('üìä Student doc not found by auth UID, querying by uid field...');
      const studentQuery = await adminDb.collection('students')
        .where('uid', '==', studentUid)
        .limit(1)
        .get();

      if (!studentQuery.empty) {
        studentDoc = studentQuery.docs[0];
        studentData = studentDoc.data();
        console.log('‚úÖ Found student by uid field query');
      } else {
        // Try by email as fallback
        const userDoc = await adminDb.collection('users').doc(studentUid).get();
        if (userDoc.exists) {
          const email = userDoc.data()?.email;
          if (email) {
            const emailQuery = await adminDb.collection('students')
              .where('email', '==', email)
              .limit(1)
              .get();

            if (!emailQuery.empty) {
              studentDoc = emailQuery.docs[0];
              studentData = studentDoc.data();
              console.log('‚úÖ Found student by email query');
            }
          }
        }
      }
    }

    if (!studentData) {
      return NextResponse.json({ error: 'Student not found' }, { status: 404 });
    }

    // Verify student is assigned to this bus (check both busId and assignedBusId for compatibility)
    const studentBusId = studentData?.busId || studentData?.assignedBusId;
    if (!studentBusId) {
      return NextResponse.json({
        error: 'Student not assigned to any bus. Please contact the administrator.'
      }, { status: 403 });
    }

    if (studentBusId !== busId) {
      console.error(`Student assigned to bus ${studentBusId}, but trying to raise flag for bus ${busId}`);
      return NextResponse.json({
        error: `Student not assigned to this bus. You are assigned to bus ${studentBusId}.`
      }, { status: 403 });
    }

    // Get route ID if not provided
    let actualRouteId = routeId;
    if (!actualRouteId) {
      const busDoc = await adminDb.collection('buses').doc(busId).get();
      if (busDoc.exists) {
        actualRouteId = busDoc.data()?.routeId;
      }
    }

    // Use the student document ID (not auth UID) for consistency
    const actualStudentId = studentDoc.id;

    // Check for existing active flags to prevent duplicates
    const { data: existingFlags, error: existingFlagError } = await supabase
      .from('waiting_flags')
      .select('*')
      .eq('student_uid', actualStudentId)
      .eq('bus_id', busId)
      .in('status', ['raised', 'waiting', 'acknowledged'])
      .limit(1);

    if (!existingFlagError && existingFlags && existingFlags.length > 0) {
      console.log('‚ö†Ô∏è Student already has an active waiting flag');
      return NextResponse.json({
        success: false,
        error: 'You already have an active waiting flag for this bus',
        existingFlagId: existingFlags[0].id
      }, { status: 409 }); // Conflict
    }

    // Get current timestamp
    const currentTimestamp = timestamp || Date.now();

    // Create waiting flag data - match the exact schema from Supabase
    // Let Supabase auto-generate the UUID id field

    const flagData: any = {
      // id is auto-generated by Supabase (UUID)
      student_uid: actualStudentId, // Use document ID for consistency
      student_name: studentData?.fullName || studentData?.name || 'Student',
      bus_id: busId,
      route_id: actualRouteId || 'unknown',
      stop_id: stopId || 'unknown',
      stop_name: stopName || 'Unknown Stop',
      status: 'raised', // Changed from 'waiting' to 'raised' to match schema
      created_at: new Date(currentTimestamp).toISOString(),
    };

    // Add location fields - REQUIRED for driver to see student on map
    // Note: waiting_flags table uses stop_lat/stop_lng for the stop location
    // If specific lat/lng provided (student's exact location), use those
    // Otherwise fallback to stopLat/stopLng from the stop data
    if (lat !== undefined && lng !== undefined) {
      flagData.stop_lat = parseFloat(lat);
      flagData.stop_lng = parseFloat(lng);
    } else if (stopLat !== undefined && stopLng !== undefined) {
      flagData.stop_lat = parseFloat(stopLat);
      flagData.stop_lng = parseFloat(stopLng);
    } else {
      // Coordinates are required for the driver to see the student on the map
      console.error('‚ùå No coordinates provided for waiting flag');
      return NextResponse.json({
        error: 'Location is required to raise a waiting flag. Please enable location services and try again.',
        code: 'LOCATION_REQUIRED'
      }, { status: 400 });
    }

    // Validate coordinates are valid numbers
    if (isNaN(flagData.stop_lat) || isNaN(flagData.stop_lng) ||
      flagData.stop_lat === 0 || flagData.stop_lng === 0) {
      console.error('‚ùå Invalid coordinates:', { lat: flagData.stop_lat, lng: flagData.stop_lng });
      return NextResponse.json({
        error: 'Invalid location coordinates. Please try again with location services enabled.',
        code: 'INVALID_COORDINATES'
      }, { status: 400 });
    }

    console.log('üìç Waiting flag location:', { lat: flagData.stop_lat, lng: flagData.stop_lng });

    if (message !== undefined) {
      flagData.message = message;
    }

    // Note: stop_id and stop_name are already set above as required fields with defaults

    console.log('Creating waiting flag with data:', flagData);

    // Store in Supabase for real-time sharing
    const { data, error: supabaseError } = await supabase
      .from('waiting_flags')
      .insert(flagData)
      .select();

    if (supabaseError) {
      console.error('Supabase insert error:', supabaseError);
      console.error('Error details:', {
        code: supabaseError.code,
        details: supabaseError.details,
        hint: supabaseError.hint,
        message: supabaseError.message
      });

      return NextResponse.json(
        {
          error: 'Failed to create waiting flag: ' + supabaseError.message,
          details: supabaseError
        },
        { status: 500 }
      );
    }

    console.log('Supabase insert successful:', data);

    const insertedFlag = data[0];
    const flagId = insertedFlag.id;

    // Also store in Firestore for persistence - REMOVED per user request
    console.log('‚úÖ Skipped Firestore write for waiting flag');

    // Broadcast waiting flag to driver
    try {
      const channel = supabase.channel(`waiting_flags_${busId}`);

      // IMPORTANT: Must subscribe to channel before sending broadcast
      // Wait for subscription to be ready
      await new Promise<void>((resolve, reject) => {
        const timeout = setTimeout(() => {
          console.warn('‚ö†Ô∏è Channel subscription timeout - sending anyway');
          resolve();
        }, 3000); // 3 second timeout

        channel.subscribe((status) => {
          if (status === 'SUBSCRIBED') {
            clearTimeout(timeout);
            resolve();
          } else if (status === 'CHANNEL_ERROR') {
            clearTimeout(timeout);
            console.warn('‚ö†Ô∏è Channel subscription error');
            resolve(); // Continue anyway
          }
        });
      });

      const broadcastResult = await channel.send({
        type: 'broadcast',
        event: 'waiting_flag_created',
        payload: insertedFlag
      });

      console.log('üì¢ Broadcast result:', broadcastResult);

      if (broadcastResult !== 'ok') {
        console.warn('Broadcast returned non-ok result (non-critical):', broadcastResult);
      }

      // Clean up channel after broadcast
      await supabase.removeChannel(channel);
    } catch (broadcastError) {
      console.warn('Broadcast failed (non-critical):', broadcastError);
    }

    // NOTE: No FCM for waiting flags - only in-app toast via broadcast
    // FCM is reserved for trip start/end only to avoid notification spam
    console.log('‚úÖ Waiting flag created - driver will see in-app toast via broadcast');

    return NextResponse.json({
      success: true,
      message: 'Waiting flag created successfully',
      flagId: flagId,
      flag: insertedFlag
    });

  } catch (error: any) {
    console.error('Error creating waiting flag:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create waiting flag' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request) {
  try {
    const body = await request.json();
    const { idToken, flagId, busId } = body;

    // Get token from either body or Authorization header
    let token = idToken;
    if (!token) {
      const authHeader = request.headers.get('authorization');
      if (authHeader && authHeader.startsWith('Bearer ')) {
        token = authHeader.substring(7);
      }
    }

    if (!token || !flagId || !busId) {
      return NextResponse.json(
        { error: 'Missing required fields: idToken, flagId, busId' },
        { status: 400 }
      );
    }

    if (!auth) {
      return NextResponse.json(
        { error: 'Firebase Admin not initialized' },
        { status: 500 }
      );
    }

    // Verify Firebase ID token
    const decodedToken = await auth.verifyIdToken(token);
    const studentUid = decodedToken.uid;

    // Remove from Supabase
    const { error: supabaseError } = await supabase
      .from('waiting_flags')
      .update({ status: 'cancelled' }) // Update status instead of delete for audit trail
      .eq('id', flagId)
      .eq('student_uid', studentUid);

    if (supabaseError) {
      console.error('Supabase error:', supabaseError);
      return NextResponse.json(
        { error: 'Failed to remove waiting flag' },
        { status: 500 }
      );
    }

    // Update in Firestore - REMOVED per user request
    console.log('‚úÖ Skipped Firestore update for waiting flag cancellation');

    // Broadcast flag removal
    try {
      const channel = supabase.channel(`waiting_flags_${busId}`);

      // Subscribe before sending
      await new Promise<void>((resolve) => {
        const timeout = setTimeout(() => resolve(), 3000);
        channel.subscribe((status) => {
          if (status === 'SUBSCRIBED' || status === 'CHANNEL_ERROR') {
            clearTimeout(timeout);
            resolve();
          }
        });
      });

      const broadcastResult = await channel.send({
        type: 'broadcast',
        event: 'waiting_flag_removed',
        payload: { flagId, studentUid }
      });

      if (broadcastResult !== 'ok') {
        console.warn('Broadcast error (non-critical):', broadcastResult);
      }

      await supabase.removeChannel(channel);
    } catch (broadcastError) {
      console.warn('Broadcast failed (non-critical):', broadcastError);
    }

    return NextResponse.json({
      success: true,
      message: 'Waiting flag removed successfully'
    });

  } catch (error: any) {
    console.error('Error removing waiting flag:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to remove waiting flag' },
      { status: 500 }
    );
  }
}